"""ReportGenerator for creating test result reports in multiple formats."""

import yaml
import hashlib
from pathlib import Path
from datetime import datetime
from src.test_harness.models import TestReport, OutputArtifact, OutputFormat


class ReportGenerator:
    """Generates test reports in YAML and Markdown formats."""

    def __init__(self, output_dir: Path):
        """Initialize generator with output directory.

        Args:
            output_dir: Directory where reports will be saved
        """
        self.output_dir = output_dir
        self.output_dir.mkdir(parents=True, exist_ok=True)

    def generate_report(self, report: TestReport) -> tuple[str, str]:
        """Generate both YAML and Markdown reports.

        Args:
            report: TestReport to generate reports from

        Returns:
            Tuple of (yaml_path, markdown_path)
        """
        timestamp = datetime.now().strftime("%Y-%m-%d-%H%M%S")
        yaml_path = self.output_dir / f"{timestamp}.yaml"
        md_path = self.output_dir / f"{timestamp}.md"

        self.generate_yaml(report, yaml_path)
        self.generate_markdown(report, md_path)

        return (str(yaml_path), str(md_path))

    def generate_yaml(self, report: TestReport, path: Path) -> None:
        """Generate YAML report file.

        Args:
            report: TestReport to serialize
            path: Output file path
        """
        data = {
            "suite_name": report.suite_name,
            "execution_date": report.execution_date.isoformat(),
            "total_commands": report.total_commands,
            "passed_count": report.passed_count,
            "failed_count": report.failed_count,
            "total_duration_seconds": round(report.total_duration_seconds, 2),
            "pass_rate": round(report.pass_rate, 2),
            "environment": report.environment,
            "results": [
                {
                    "command": r.command_name,
                    "status": r.status.value,
                    "execution_time": round(r.execution_time_seconds, 2),
                    "exit_code": r.exit_code,
                    "artifacts": r.artifacts_created,
                    "timestamp": r.timestamp.isoformat()
                }
                for r in report.results
            ]
        }

        with open(path, 'w') as f:
            yaml.dump(data, f, default_flow_style=False, sort_keys=False)

    def generate_markdown(self, report: TestReport, path: Path) -> None:
        """Generate Markdown report file.

        Args:
            report: TestReport to format
            path: Output file path
        """
        content = f"""# Slash Command Validation Report

**Suite**: {report.suite_name}
**Date**: {report.execution_date.isoformat()}
**Environment**: {report.environment}

## Summary

- **Total Commands**: {report.total_commands}
- **Passed**: {report.passed_count} ({report.pass_rate:.1f}%)
- **Failed**: {report.failed_count}
- **Duration**: {report.total_duration_seconds:.2f} seconds

## Results

"""
        for result in report.results:
            icon = "✅" if result.passed else "❌"
            content += f"""### {icon} {result.command_name} - {result.status.value}

- **Duration**: {result.execution_time_seconds:.2f}s
- **Exit Code**: {result.exit_code}
- **Artifacts**: {', '.join(result.artifacts_created) if result.artifacts_created else 'None'}
- **Timestamp**: {result.timestamp.isoformat()}

"""
            if result.stderr:
                content += f"""**Errors**:
```
{result.stderr}
```

"""

        content += """---

**Generated by**: Slash Command Test Harness
"""

        with open(path, 'w') as f:
            f.write(content)

    def _calculate_checksum(self, file_path: Path) -> str:
        """Calculate SHA256 checksum of file.

        Args:
            file_path: Path to file

        Returns:
            Hex digest of file checksum
        """
        sha256 = hashlib.sha256()
        with open(file_path, 'rb') as f:
            for chunk in iter(lambda: f.read(4096), b''):
                sha256.update(chunk)
        return sha256.hexdigest()
